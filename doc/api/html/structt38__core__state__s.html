<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>spandsp: t38_core_state_s Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="css.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">spandsp
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structt38__core__state__s.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structt38__core__state__s-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">t38_core_state_s Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="private_2t38__core_8h_source.html">t38_core.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a21e5d6267546112ff785eab6a029882b"><td class="memItemLeft" align="right" valign="top"><a id="a21e5d6267546112ff785eab6a029882b"></a>
t38_tx_packet_handler_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#a21e5d6267546112ff785eab6a029882b">tx_packet_handler</a></td></tr>
<tr class="memdesc:a21e5d6267546112ff785eab6a029882b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler routine to transmit IFP packets generated by the T.38 protocol engine. <br /></td></tr>
<tr class="separator:a21e5d6267546112ff785eab6a029882b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab76bfa8e89b37afb8f6ee97d1e7ff26"><td class="memItemLeft" align="right" valign="top"><a id="aab76bfa8e89b37afb8f6ee97d1e7ff26"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#aab76bfa8e89b37afb8f6ee97d1e7ff26">tx_packet_user_data</a></td></tr>
<tr class="memdesc:aab76bfa8e89b37afb8f6ee97d1e7ff26"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque pointer passed to tx_packet_handler. <br /></td></tr>
<tr class="separator:aab76bfa8e89b37afb8f6ee97d1e7ff26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7dacd27b74afc01a5bc0cde40745e6"><td class="memItemLeft" align="right" valign="top"><a id="a8f7dacd27b74afc01a5bc0cde40745e6"></a>
t38_rx_indicator_handler_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#a8f7dacd27b74afc01a5bc0cde40745e6">rx_indicator_handler</a></td></tr>
<tr class="memdesc:a8f7dacd27b74afc01a5bc0cde40745e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler routine to process received indicator packets. <br /></td></tr>
<tr class="separator:a8f7dacd27b74afc01a5bc0cde40745e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675c507d956fc96008010a2717d01f18"><td class="memItemLeft" align="right" valign="top"><a id="a675c507d956fc96008010a2717d01f18"></a>
t38_rx_data_handler_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#a675c507d956fc96008010a2717d01f18">rx_data_handler</a></td></tr>
<tr class="memdesc:a675c507d956fc96008010a2717d01f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler routine to process received data packets. <br /></td></tr>
<tr class="separator:a675c507d956fc96008010a2717d01f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e95c838a8b9d6caddf4bb76b157d796"><td class="memItemLeft" align="right" valign="top"><a id="a3e95c838a8b9d6caddf4bb76b157d796"></a>
t38_rx_missing_handler_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#a3e95c838a8b9d6caddf4bb76b157d796">rx_missing_handler</a></td></tr>
<tr class="memdesc:a3e95c838a8b9d6caddf4bb76b157d796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler routine to process the missing packet condition. <br /></td></tr>
<tr class="separator:a3e95c838a8b9d6caddf4bb76b157d796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aefab3fc56df2b7b11af6548d1eea99"><td class="memItemLeft" align="right" valign="top"><a id="a5aefab3fc56df2b7b11af6548d1eea99"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#a5aefab3fc56df2b7b11af6548d1eea99">rx_user_data</a></td></tr>
<tr class="memdesc:a5aefab3fc56df2b7b11af6548d1eea99"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque pointer passed to any of the above receive handling routines. <br /></td></tr>
<tr class="separator:a5aefab3fc56df2b7b11af6548d1eea99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a4587ab6b62654fcb7a04f8fb2d729"><td class="memItemLeft" align="right" valign="top"><a id="ab8a4587ab6b62654fcb7a04f8fb2d729"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#ab8a4587ab6b62654fcb7a04f8fb2d729">microseconds_per_tx_chunk</a></td></tr>
<tr class="memdesc:ab8a4587ab6b62654fcb7a04f8fb2d729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Required time between T.38 transmissions, in us. <br /></td></tr>
<tr class="separator:ab8a4587ab6b62654fcb7a04f8fb2d729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8842a7079a4a8735574987e7d6908d71"><td class="memItemLeft" align="right" valign="top"><a id="a8842a7079a4a8735574987e7d6908d71"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#a8842a7079a4a8735574987e7d6908d71">chunking_modes</a></td></tr>
<tr class="memdesc:a8842a7079a4a8735574987e7d6908d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit fields controlling the way data is packed into chunks for transmission. <br /></td></tr>
<tr class="separator:a8842a7079a4a8735574987e7d6908d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39e2a2ed17351eeeef509d8cba8a8a0"><td class="memItemLeft" align="right" valign="top"><a id="ac39e2a2ed17351eeeef509d8cba8a8a0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#ac39e2a2ed17351eeeef509d8cba8a8a0">iaf</a></td></tr>
<tr class="memdesc:ac39e2a2ed17351eeeef509d8cba8a8a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internet Aware FAX mode bit mask. <br /></td></tr>
<tr class="separator:ac39e2a2ed17351eeeef509d8cba8a8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58b4f44ce83c739a0664e9016070d03"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#ae58b4f44ce83c739a0664e9016070d03">data_rate_management_method</a></td></tr>
<tr class="memdesc:ae58b4f44ce83c739a0664e9016070d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method 1: Local generation of TCF (required for use with TCP). Method 2: Transfer of TCF is required for use with UDP (UDPTL or RTP). Method 2 is not recommended for use with TCP.  <a href="structt38__core__state__s.html#ae58b4f44ce83c739a0664e9016070d03">More...</a><br /></td></tr>
<tr class="separator:ae58b4f44ce83c739a0664e9016070d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44698e74f3c2a76bb0501dae7765312c"><td class="memItemLeft" align="right" valign="top"><a id="a44698e74f3c2a76bb0501dae7765312c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#a44698e74f3c2a76bb0501dae7765312c">data_transport_protocol</a></td></tr>
<tr class="memdesc:a44698e74f3c2a76bb0501dae7765312c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The emitting gateway may indicate a preference for either UDP/UDPTL, or UDP/RTP, or TCP for transport of T.38 IFP Packets. The receiving device selects the transport protocol. <br /></td></tr>
<tr class="separator:a44698e74f3c2a76bb0501dae7765312c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d57264b0607c5a2f3263665ae5a5e25"><td class="memItemLeft" align="right" valign="top"><a id="a3d57264b0607c5a2f3263665ae5a5e25"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#a3d57264b0607c5a2f3263665ae5a5e25">fill_bit_removal</a></td></tr>
<tr class="memdesc:a3d57264b0607c5a2f3263665ae5a5e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the capability to remove and insert fill bits in Phase C, non-ECM data to reduce bandwidth in the packet network. <br /></td></tr>
<tr class="separator:a3d57264b0607c5a2f3263665ae5a5e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e6a345a1ce6e3fbf58b430b2073b71"><td class="memItemLeft" align="right" valign="top"><a id="ae4e6a345a1ce6e3fbf58b430b2073b71"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#ae4e6a345a1ce6e3fbf58b430b2073b71">mmr_transcoding</a></td></tr>
<tr class="memdesc:ae4e6a345a1ce6e3fbf58b430b2073b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the ability to convert to/from MMR from/to the line format to improve the compression of the data, and reduce the bandwidth, in the packet network. <br /></td></tr>
<tr class="separator:ae4e6a345a1ce6e3fbf58b430b2073b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0cd00237f92ce9900494a2547bf4821"><td class="memItemLeft" align="right" valign="top"><a id="aa0cd00237f92ce9900494a2547bf4821"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#aa0cd00237f92ce9900494a2547bf4821">jbig_transcoding</a></td></tr>
<tr class="memdesc:aa0cd00237f92ce9900494a2547bf4821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the ability to convert to/from JBIG to reduce bandwidth. <br /></td></tr>
<tr class="separator:aa0cd00237f92ce9900494a2547bf4821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200596ca646c839ab467e80c8c8180b8"><td class="memItemLeft" align="right" valign="top"><a id="a200596ca646c839ab467e80c8c8180b8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#a200596ca646c839ab467e80c8c8180b8">max_buffer_size</a></td></tr>
<tr class="memdesc:a200596ca646c839ab467e80c8c8180b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">For UDP (UDPTL or RTP) modes, this option indicates the maximum number of octets that can be stored on the remote device before an overflow condition occurs. It is the responsibility of the transmitting application to limit the transfer rate to prevent an overflow. The negotiated data rate should be used to determine the rate at which data is being removed from the buffer. <br /></td></tr>
<tr class="separator:a200596ca646c839ab467e80c8c8180b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591708157ff8450d1a7d2d3f960b897f"><td class="memItemLeft" align="right" valign="top"><a id="a591708157ff8450d1a7d2d3f960b897f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#a591708157ff8450d1a7d2d3f960b897f">max_datagram_size</a></td></tr>
<tr class="memdesc:a591708157ff8450d1a7d2d3f960b897f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This option indicates the maximum size of a UDPTL packet or the maximum size of the payload within an RTP packet that can be accepted by the remote device. <br /></td></tr>
<tr class="separator:a591708157ff8450d1a7d2d3f960b897f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d16721b1fd85267746c57617d917ac"><td class="memItemLeft" align="right" valign="top"><a id="ab6d16721b1fd85267746c57617d917ac"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#ab6d16721b1fd85267746c57617d917ac">t38_version</a></td></tr>
<tr class="memdesc:ab6d16721b1fd85267746c57617d917ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the version number of ITU-T Rec. T.38. New versions shall be compatible with previous versions. <br /></td></tr>
<tr class="separator:ab6d16721b1fd85267746c57617d917ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e6f7466214b488652c6d29580795cf"><td class="memItemLeft" align="right" valign="top"><a id="af7e6f7466214b488652c6d29580795cf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#af7e6f7466214b488652c6d29580795cf">allow_for_tep</a></td></tr>
<tr class="memdesc:af7e6f7466214b488652c6d29580795cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow time for TEP playout. <br /></td></tr>
<tr class="separator:af7e6f7466214b488652c6d29580795cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3448607e4450ab552011a94ccf6d397e"><td class="memItemLeft" align="right" valign="top"><a id="a3448607e4450ab552011a94ccf6d397e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#a3448607e4450ab552011a94ccf6d397e">fastest_image_data_rate</a></td></tr>
<tr class="memdesc:a3448607e4450ab552011a94ccf6d397e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fastest data rate supported by the T.38 channel. <br /></td></tr>
<tr class="separator:a3448607e4450ab552011a94ccf6d397e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec0b95145276de06b301530f67ec771"><td class="memItemLeft" align="right" valign="top"><a id="a7ec0b95145276de06b301530f67ec771"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#a7ec0b95145276de06b301530f67ec771">pace_transmission</a></td></tr>
<tr class="memdesc:a7ec0b95145276de06b301530f67ec771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pace transmission. <br /></td></tr>
<tr class="separator:a7ec0b95145276de06b301530f67ec771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec01d06dcf27021a0931f85bb302bc0a"><td class="memItemLeft" align="right" valign="top"><a id="aec01d06dcf27021a0931f85bb302bc0a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#aec01d06dcf27021a0931f85bb302bc0a">check_sequence_numbers</a></td></tr>
<tr class="memdesc:aec01d06dcf27021a0931f85bb302bc0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if IFP packet sequence numbers are relevant. For some transports, like TPKT over TCP they are not relevent. <br /></td></tr>
<tr class="separator:aec01d06dcf27021a0931f85bb302bc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add73275da657881cae1e9e3c318eb09c"><td class="memItemLeft" align="right" valign="top"><a id="add73275da657881cae1e9e3c318eb09c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#add73275da657881cae1e9e3c318eb09c">category_control</a> [5]</td></tr>
<tr class="memdesc:add73275da657881cae1e9e3c318eb09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of times each packet type will be sent (low byte). The depth of redundancy (2nd byte). Higher numbers may increase reliability for UDP transmission. Zero is valid for the indicator packet category, to suppress all indicator packets (typicaly for TCP transmission). <br /></td></tr>
<tr class="separator:add73275da657881cae1e9e3c318eb09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14dc01861e3c4b27b1cc37280e1d00e0"><td class="memItemLeft" align="right" valign="top"><a id="a14dc01861e3c4b27b1cc37280e1d00e0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#a14dc01861e3c4b27b1cc37280e1d00e0">tx_seq_no</a></td></tr>
<tr class="memdesc:a14dc01861e3c4b27b1cc37280e1d00e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sequence number for the next packet to be transmitted. <br /></td></tr>
<tr class="separator:a14dc01861e3c4b27b1cc37280e1d00e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68885dd09006e5b99a9d1a591d05ecfe"><td class="memItemLeft" align="right" valign="top"><a id="a68885dd09006e5b99a9d1a591d05ecfe"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#a68885dd09006e5b99a9d1a591d05ecfe">rx_expected_seq_no</a></td></tr>
<tr class="memdesc:a68885dd09006e5b99a9d1a591d05ecfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sequence number expected in the next received packet. <br /></td></tr>
<tr class="separator:a68885dd09006e5b99a9d1a591d05ecfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa8b9c0e0682e86a27b7945480dab2b"><td class="memItemLeft" align="right" valign="top"><a id="acfa8b9c0e0682e86a27b7945480dab2b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#acfa8b9c0e0682e86a27b7945480dab2b">current_rx_indicator</a></td></tr>
<tr class="memdesc:acfa8b9c0e0682e86a27b7945480dab2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current receive indicator - i.e. the last indicator received. <br /></td></tr>
<tr class="separator:acfa8b9c0e0682e86a27b7945480dab2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfa434301767c595d4371a9d030644c"><td class="memItemLeft" align="right" valign="top"><a id="acbfa434301767c595d4371a9d030644c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#acbfa434301767c595d4371a9d030644c">current_rx_data_type</a></td></tr>
<tr class="memdesc:acbfa434301767c595d4371a9d030644c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current receive data type - i.e. the last data type received. <br /></td></tr>
<tr class="separator:acbfa434301767c595d4371a9d030644c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f85116e12b795a4931a92a90c020de"><td class="memItemLeft" align="right" valign="top"><a id="a10f85116e12b795a4931a92a90c020de"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#a10f85116e12b795a4931a92a90c020de">current_rx_field_type</a></td></tr>
<tr class="memdesc:a10f85116e12b795a4931a92a90c020de"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current receive field type - i.e. the last field_type received. <br /></td></tr>
<tr class="separator:a10f85116e12b795a4931a92a90c020de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1503d03f3169ffa58146878081e049"><td class="memItemLeft" align="right" valign="top"><a id="a0f1503d03f3169ffa58146878081e049"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#a0f1503d03f3169ffa58146878081e049">current_tx_indicator</a></td></tr>
<tr class="memdesc:a0f1503d03f3169ffa58146878081e049"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current transmit indicator - i.e. the last indicator transmitted. <br /></td></tr>
<tr class="separator:a0f1503d03f3169ffa58146878081e049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9298e6542d3148bb819728c1236c861"><td class="memItemLeft" align="right" valign="top"><a id="aa9298e6542d3148bb819728c1236c861"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#aa9298e6542d3148bb819728c1236c861">v34_rate</a></td></tr>
<tr class="memdesc:aa9298e6542d3148bb819728c1236c861"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bit rate for V.34 operation. <br /></td></tr>
<tr class="separator:aa9298e6542d3148bb819728c1236c861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ae1bb629594293f9d3ced2a5275020"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#a13ae1bb629594293f9d3ced2a5275020">missing_packets</a></td></tr>
<tr class="separator:a13ae1bb629594293f9d3ced2a5275020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4205c9b08dec0f7387b77899d146076"><td class="memItemLeft" align="right" valign="top"><a id="ad4205c9b08dec0f7387b77899d146076"></a>
<a class="el" href="logging_8h.html#acdcb0eb50282ffb98a3283c7c2e5d246">logging_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt38__core__state__s.html#ad4205c9b08dec0f7387b77899d146076">logging</a></td></tr>
<tr class="memdesc:ad4205c9b08dec0f7387b77899d146076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error and flow logging control. <br /></td></tr>
<tr class="separator:ad4205c9b08dec0f7387b77899d146076"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Core T.38 state, common to all modes of T.38. Higher layers should support the specifics of a gateway, terminal, T.31 interface, etc and incorporate an instance of this structure to handle the basics of T.38, mostly IFP. </p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a id="ae58b4f44ce83c739a0664e9016070d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58b4f44ce83c739a0664e9016070d03">&#9670;&nbsp;</a></span>data_rate_management_method</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t38_core_state_s::data_rate_management_method</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method 1: Local generation of TCF (required for use with TCP). Method 2: Transfer of TCF is required for use with UDP (UDPTL or RTP). Method 2 is not recommended for use with TCP. </p>
<p>NOTE - Bandwidth reduction shall only be done on suitable Phase C data, i.e., MH, MR and - in the case of transcoding to JBIG - MMR. MMR and JBIG require reliable data transport such as that provided by TCP. When transcoding is selected, it shall be applied to every suitable page in a call. </p>

<p class="reference">Referenced by <a class="el" href="t38__core_8c.html#a1170d36f0ebf0b286058567e294871bc">t38_set_data_rate_management_method()</a>.</p>

</div>
</div>
<a id="a13ae1bb629594293f9d3ced2a5275020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ae1bb629594293f9d3ced2a5275020">&#9670;&nbsp;</a></span>missing_packets</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t38_core_state_s::missing_packets</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A count of missing receive packets. This count might not be accurate if the received packet numbers jump wildly. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="private_2t38__core_8h_source.html">private/t38_core.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structt38__core__state__s.html">t38_core_state_s</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
